#!/bin/bash

# DO NOT EDIT THIS FILE
# Put your changes at scripts/custom.sh


########################################################
## Variables Creation                                 ##
########################################################

# check if variable with such name already exist
# $1 - list
# $2 - variable name
function name_exist ()
{
    local list i

    eval list="\$$1"
    for i in $list; do
        [ "$2" == "$i" ] && return 0
    done
    return 1
}

# add new variable
# $1 - variable name
# $2 - help string, description
# $3 - init code suitable for 'eval var=$code'
function add_var ()
{
    name_exist vars "$1" && error "Variable $1 already exists"
    vars="$vars $1" # to know var creation order, it's important
    eval help_$1="\"$2\""
    eval init_$1="'$3'"
    set_write_func $1 write_text_var
}

# adds yesno variable
function add_yesno_var ()
{
    add_var "$@"
    set_write_func $1 write_yesno_var
    add_init_hooks $1 test_yes_no
}

# adds set of variables for package compilation, namely: pkg_cflags, pkg_libs
# and pkg_ver.
# $1 - variable name
# $2 - package name
# $3 - pkg-config version check arguments, added as init hook
function add_pkg_vars ()
{
    add_var $1_cflags "$2 cflags" \
    "\`RFS=\$rfs scripts/rfs-pkg-config --cflags $2\`"
    add_var $1_libs "$2 libs" \
    "\`RFS=\$rfs scripts/rfs-pkg-config --libs $2\`"
    add_var $1_ver "$2 version" \
    "\`RFS=\$rfs scripts/rfs-pkg-config --modversion  $2\`"
    if [ -n "$3" ]; then
        eval $1_version_check="\"$2 $3\""         #\""
        add_init_hooks $1_ver version_check
    fi
}

# deletes variable
function ignore_var ()
{
    ignore_vars="$ignore_vars $1"
    set_write_func $1 true
}

# hides variable from command line
function hide_from_cmd ()
{
    const_vars="${const_vars} $1"
}

# set variable's initialization code
# $1 - variable name
# $2 - init code
function set_init_code ()
{
    eval init_$1="'$2'"
}

# adds variable's init hook. init hooks are function names not bash code as in
# init code. Reason - simplicity of implementation. Limitations - none. Take any
# bash code, put it inside function block, pass function name to add_init_hook.
# $1 - variable name
# $2-n - function names
function add_init_hooks ()
{
    local h

    ! name_exist vars $1 && error "add_init_hook: $1 - no such variable"
    h=hook_$1
    shift
    eval $h="\"\${$h} $@\""
}

# adds write function. Its duty to write variable definition in different
# formats - C, Makefile, sed
# $1 - variable
# $2 - name of write function
function set_write_func ()
{
    local h

    ! name_exist vars $1 && error "add_init_hook: $1 - no such variable"
    h=write_$1
    eval $h="\"$2\""
}

# sets variable value
# $1 - variable name
# $2 - value
function set_value ()
{
    eval set_$1=1
    eval $1="\"$2\""
}

# converts variable name to bash format
# $1 - variable name
function unify_name ()
{
    echo ${1//-/_}
}

########################################################
## Command line procesing                             ##
########################################################

# processes command line arguments
function cmd_processing ()
{
    local arg arg2
    while [ $# -gt 0 ]; do
        arg="$1"
        shift
        if [ "${arg:0:2}" == "--" ]; then
            arg2="${arg:2}"
            test_set_var "$arg2" && continue
            test_set_cmd "$arg2" && continue
        else
            echo "make file vars may be here"
        fi
        error "$arg - unknown argument"
    done
}

# tests if token is a variable and sets its init code
function test_set_var ()
{
    local var value

    var=${1%%=*}
    value=${1#*=}
    [ "$var" == "$1" ] && return 1 # token has no '=' sign
    var=`unify_name "$var"`
    ! name_exist vars "$var" && return 1
    name_exist const_vars "$var" && return 1
    set_init_code "$var" "$value"
}

# tests if token is a command and runs it
function test_set_cmd ()
{
    [ "$1" == "help" ] && usage
    return 1
}

########################################################
## Value Evaluation                                   ##
########################################################

# evaluates initialization code and assigns values to variables
# if any hooks were set, runs them also
function value_evaluation ()
{
    local s

    for i in $vars; do
        name_exist ignore_vars $i && continue

        # if var still has no value - init it
        eval s="\${set_$i}"
        if [ -z "$s" ]; then
            eval s="\${init_$i}"
            set_value $i "$s" || error "can't evaluate $i from $s"
        fi

        # run all hooks
        eval s="\${hook_$i}"
        for j in $s; do
            $j $i || error "hook '$j' failed for var '$i'"
        done
    done
}

########################################################
## Writing Configuration Files                        ##
########################################################

# writes configuration files
function write_configs ()
{
    local var value i str="\n"

    str="$str# Generated by configure script\n"
    str="$str# date: `date`\n"
    str="$str# pwd : `pwd`\n"
    str="$str# args: $CMD\n"
    echo -e "/*$str*/" > config.h
    echo -e "$str" > config.mk
    echo > subst.sed
    for i in $vars; do
        # var was deleted
        name_exist ignore_vars $i && continue
        eval value="\$$i"
        var=`tr "[:lower:]" "[:upper:]" <<< $i`
        eval \${write_$i} "$var" "\"$value\""
    done
    echo "Creating config.h"
    echo "Creating config.mk"
    #echo "subst.sed"
}

########################################################
## Pattern Substitution for *.in files                ##
########################################################
function do_in_files ()
{
    find . -name "*.in" | while read line; do
        echo "Creating ${line%.in}"
        sed -f subst.sed < "$line" > "${line%.in}"
    done
}

########################################################
## Misc Code                                          ##
########################################################


CMD="$@"

# list of all variables
vars=""


function bslash ()
{
    p1="%%`tr [:upper:] [:lower:] <<< $1`%%"
    t="$2"
    p2=`sed -e 's/\//\\\\\//g' <<< $t`
    echo "s/$p1/$p2/g"
}


function usage ()
{
    echo "Usage: ./configure [variables]"
    echo

    echo "Variables are set with '--variable=value'"
    echo "Defined variables are:"
    for i in $vars; do
        printf "%11s  "  $i
        eval echo "\${help_$i} [\${init_$i}]"
    done
    echo

    echo "For example:"
    echo "./configure --datadir=/usr/local/share"
    echo
    exit $1
}


function error ()
{
    echo "configure: $@"
    exit 1
}

function print_all ()
{
    echo "Defined variables: $vars"
    for i in $vars; do
        echo "name: $i"
        eval s="\"\$$i\""
        echo "value: $s"
        eval s="\${set_$i}"
        echo "set: $s"
        eval s="\${init_$i}"
        echo "init: $s"
        eval s="\${hook_$i}"
        echo "hooks: $s"
        echo
    done
}


# all hooks get one parameters - variable name

# Checks that value is 'yes' or 'no'.
function test_yes_no ()
{
    local s

    eval s="\"\$$1\""
    case "$s" in
        "yes" | "no" )
            return 0
            ;;
        *)
            echo "'$1' value must be 'yes' or 'no'"
            return 1
            ;;
    esac
    return 0
}

# writes text variable
# $1 - variable
# $2 - value
function write_text_var ()
{
    echo "#define $1 \"$2\"" >> config.h
    echo "$1 := $2" >> config.mk
    bslash "$1" "$2" >> subst.sed
}

# writes yes/no variable
# $1 - variable
# $2 - value
function write_yesno_var ()
{
    if [ "$2" == "yes" ]; then
        echo "#define $1  1" >> config.h
        echo "$1 := yes" >> config.mk
        bslash "$1" "$2" >> subst.sed
    fi
}

# runs pkg-config to check package version
function version_check ()
{
    local v=${1%%_ver}
    local h="${v}_version_check"
    eval RFS=\$rfs scripts/rfs-pkg-config  "\${$h}" > /dev/null
}



########################################################
## Main Engine                                        ##
########################################################

# Phase 1: Variable Creation
source scripts/common.sh
source scripts/custom.sh    # <-- add you changes here 

# Phase 2: Command Line Processing
cmd_processing "$@"

# Phase 3: Value Evaluation
value_evaluation

# Phase 4: Writing Configuration Files
write_configs

# Phase 5: Pattern Substitution for *.in files
do_in_files
